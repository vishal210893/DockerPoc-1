name: Build and Deploy

on:
  push:
    branches:
      - learning/github-action

env:
  DOCKER_HUB_USER: vishal210893 # Your Docker Hub username

jobs:
  build-artifact:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the code from the repository
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Set up Java environment
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      # Step 3: Cache the local Maven repository to speed up builds
      - name: Cache local Maven repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Step 4: Build the project using Maven
      - name: Maven build
        run: mvn -q install

      # Step 4.1: Upload the built JAR as an artifact
      - name: Upload JAR artifact
        id: upload_jar
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/dockerpoc-1.jar

  docker-build-push:
    runs-on: ubuntu-latest
    needs: build-artifact
    env:
      REPO_NAME: dockerpoc-1
      DOWNLOAD_IMAGE: false  # Set to 'true' to enable image download steps
    outputs:
      deployment_image_name: ${{ steps.generate_tags.outputs.DEPLOYMENT_IMAGE_NAME_WITH_TAG }}
    steps:
      # Step 1: Checkout the code from the repository
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Download the built JAR artifact
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      # Step 3: Log in to DockerHub
      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Step 4: Log in to GitHub Container Registry (GHCR)
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USER }}
          password: ${{ secrets.GHCR_PASSWORD }}

      # Step 5: Generate image tags (includes date and Git SHA for uniqueness)
      - name: Generate image tags
        id: generate_tags
        run: |
          IMAGE_TAG_SUFFIX="$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}"
          DOCKER_HUB_IMAGE="${{ env.DOCKER_HUB_USER }}/${{ env.REPO_NAME }}:${IMAGE_TAG_SUFFIX}"
          GHCR_IMAGE="ghcr.io/${{ github.repository_owner }}/${{ env.REPO_NAME }}:${IMAGE_TAG_SUFFIX}"

          echo "DOCKER_HUB_IMAGE_WITH_TAG=${DOCKER_HUB_IMAGE}" >> $GITHUB_ENV
          echo "GHCR_IMAGE_WITH_TAG=${GHCR_IMAGE}" >> $GITHUB_ENV
          
          # This is the image name that will be used in the Kubernetes deployment
          echo "DEPLOYMENT_IMAGE_NAME_WITH_TAG=${DOCKER_HUB_IMAGE}" >> $GITHUB_OUTPUT

      # Step 6: Set up QEMU for multi-platform builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Step 7: Set up Docker Buildx for building images
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:master

      # Step 8: Build and push Docker images to registries with caching
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          file: Dockerfile
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.DOCKER_HUB_IMAGE_WITH_TAG }}
            ${{ env.GHCR_IMAGE_WITH_TAG }}
          cache-from: type=registry,ref=${{ env.DOCKER_HUB_USER }}/${{ env.REPO_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_HUB_USER }}/${{ env.REPO_NAME }}:buildcache,mode=max

      # Step 9: Save the built Docker image as a tar file (conditional)
      - name: Save Docker image as tar
        if: env.DOWNLOAD_IMAGE == 'true'
        run: |
          # Pull specific platform if needed, otherwise defaults to runner's arch
          docker pull ${{ env.DOCKER_HUB_IMAGE_WITH_TAG }} --platform linux/amd64
          docker save ${{ env.DOCKER_HUB_IMAGE_WITH_TAG }} -o ${{ env.REPO_NAME }}.tar

      # Step 10: Upload the Docker image tar as an artifact (conditional)
      - name: Upload Docker image artifact
        if: env.DOWNLOAD_IMAGE == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: ${{ env.REPO_NAME }}.tar

  update-deployment:
    runs-on: ubuntu-latest
    needs: docker-build-push
    permissions:
      contents: write # Required to push changes to the repository
    env:
      REPO_NAME: dockerpoc-1
      NEW_IMAGE_NAME: ${{ needs.docker-build-push.outputs.deployment_image_name }}
    steps:
      # Step 1: Checkout the code from the repository (with full history for rebase)
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Step 2: Update the Deployment YAML file with the new image tag
      - name: Update Deployment YAML
        run: |
          echo "Updating K8s deployment with image: ${{ env.NEW_IMAGE_NAME }}"
          # Adjust the sed regex if your image line format in Deployment.yaml is different.
          # This assumes "image: DOCKER_USER/REPO_NAME:some-old-tag"
          sed -i'' -e "s|image: ${{ env.DOCKER_HUB_USER }}/${{ env.REPO_NAME }}:.*|image: ${{ env.NEW_IMAGE_NAME }}|g" K8s_Yaml/App/Deployment.yaml
          echo "--- Updated K8s_Yaml/App/Deployment.yaml ---"
          cat K8s_Yaml/App/Deployment.yaml
          echo "-------------------------------------------"

      # Step 3: Commit and push the updated Deployment YAML file to the repository
      - name: Commit and push changes
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions-bot@github.com"
          git add K8s_Yaml/App/Deployment.yaml
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit in Deployment.yaml."
          else
            git commit -m "Update Kubernetes deployment image to ${{ env.NEW_IMAGE_NAME }}"
            # Pull with rebase before pushing to avoid conflicts if the branch was updated concurrently
            git pull --rebase origin ${{ github.ref_name }}
            git push origin ${{ github.ref_name }}
          fi