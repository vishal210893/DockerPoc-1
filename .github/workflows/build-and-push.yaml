name: Build and Deployon:  push:    branches:      #- learning/github-action      - main  workflow_dispatch:    inputs:      reason:        description: 'Reason for running the workflow'        required: false        default: 'Manual execution'# Global environment variables accessible in all jobsenv:  USER: vishal210893  REPO_NAME: dockerpoc-1jobs:  build-artifact:    permissions: write-all    name: 1️⃣ Build Java Artifact    runs-on: ubuntu-latest    container:      image: maven:3.9.6-eclipse-temurin-17 # Pinned version for consistent builds    defaults:      run:        shell: bash    steps:      # Checkout the repository code to the runner environment      - name: Checkout Repository        uses: actions/checkout@v4        with:          fetch-depth: 0 # Fetch all history for git commands in custom actions      # Set up the specified Java version for the Maven build      - name: Set up Java        uses: actions/setup-java@v4        with:          distribution: 'temurin'          java-version: '17'      # Cache Maven dependencies to speed up subsequent builds      - name: Cache Maven Repository        uses: actions/cache@v4        with:          path: ~/.m2/repository          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}          restore-keys: |            ${{ runner.os }}-maven-      # Build the Java application using Maven      - name: Build with Maven        run: mvn -B -q install # -B for batch mode, -q for quiet      # Upload the built JAR file as a workflow artifact      - name: Upload JAR Artifact        uses: actions/upload-artifact@v4        with:          name: app-jar          path: target/dockerpoc-1.jar # Ensure this path is correct      # Run the custom JavaScript action to gather system and Git information      - name: Run System & Git Info Action        id: build_info_action # Unique ID for this step        uses:  vishal210893/PrintInfo-GA-JS@v1        with:          show_extended_info: 'false' # Example: only basic info for this job      # Log the timestamp output from the custom info action      - name: Log Timestamp from Info Action        run: |          echo "Build Info Action Timestamp: ${{ steps.build_info_action.outputs.formatted_run_timestamp }}"  docker-build-push:    name: 2️⃣ Build & Push Docker Image    runs-on: ubuntu-latest    needs: build-artifact # This job depends on the successful completion of 'build-artifact'    defaults:      run:        shell: bash    outputs:      image_tag: ${{ steps.tag_generator.outputs.IMAGE_TAG }} # Output the generated image tag for use in other jobs    env:      DOWNLOAD_IMAGE: false # Control whether to download the built image as tar    steps:      # Checkout the repository code      - name: Checkout Repository        uses: actions/checkout@v4        with:          fetch-depth: 0 # Fetch all history for git commands in custom actions      # Download the JAR artifact built in the previous job      - name: Download JAR Artifact        uses: actions/download-artifact@v4        with:          name: app-jar          path: target/      # Generate a unique image tag based on the current timestamp      - name: Generate Image Tag        id: tag_generator # Clearer ID for referencing output        run: |          IMAGE_TAG_VALUE=$(date +%Y%m%d-%H%M%S)          echo "IMAGE_TAG=${IMAGE_TAG_VALUE}" >> $GITHUB_OUTPUT          echo "Generated IMAGE_TAG: ${IMAGE_TAG_VALUE}"          # Set full image names as environment variables for subsequent steps in this job          echo "DOCKER_IMAGE_WITH_TAG=${{ env.USER }}/${{ env.REPO_NAME }}:${IMAGE_TAG_VALUE}" >> $GITHUB_ENV          echo "GHCR_IMAGE_WITH_TAG=${{ env.REPO_NAME }}:${IMAGE_TAG_VALUE}" >> $GITHUB_ENV      # Log in to Docker Hub using stored secrets      - name: Login to Docker Hub        uses: docker/login-action@v3        with:          registry: docker.io          username: ${{ secrets.DOCKER_USERNAME }}          password: ${{ secrets.DOCKER_PASSWORD }}      # Log in to GitHub Container Registry (GHCR)      - name: Login to GitHub Container Registry        uses: docker/login-action@v3        with:          registry: ghcr.io          username: ${{ secrets.GHCR_USER }} # Typically ${{ github.actor }} or a dedicated service account          password: ${{ secrets.GHCR_PASSWORD }} # Typically ${{ secrets.GITHUB_TOKEN }}      # Set up QEMU for multi-architecture Docker builds (e.g., linux/amd64, linux/arm64)      - name: Set up QEMU for Multi-Arch Builds        uses: docker/setup-qemu-action@v3      # Set up Docker Buildx, a CLI plugin for extended build capabilities      - name: Set up Docker Buildx        uses: docker/setup-buildx-action@v3        with:          driver-opts: image=moby/buildkit:master # Using master for latest features, consider pinning if stability is paramount      # Build the Docker image and push it to Docker Hub and GHCR      - name: Build & Push Docker Image        uses: docker/build-push-action@v5        with:          context: .          file: ./Dockerfile # Explicitly point to Dockerfile          push: true          platforms: linux/amd64,linux/arm64          tags: |            ${{ env.DOCKER_IMAGE_WITH_TAG }}            ghcr.io/${{ github.repository_owner }}/${{ env.GHCR_IMAGE_WITH_TAG }}          labels: |            org.opencontainers.image.source=https://github.com/${{ github.repository }}            org.opencontainers.image.revision=${{ github.sha }}          cache-from: type=registry,ref=${{ env.USER }}/${{ env.REPO_NAME }}:buildcache # Consistent cache naming          cache-to: type=registry,ref=${{ env.USER }}/${{ env.REPO_NAME }}:buildcache,mode=max      # Optionally save the built Docker image as a .tar file      - name: Save Image as Tar (Optional)        if: env.DOWNLOAD_IMAGE == 'true'        run: |          echo "Saving image ${{ env.DOCKER_IMAGE_WITH_TAG }} to tar..."          docker pull ${{ env.DOCKER_IMAGE_WITH_TAG }}          docker save ${{ env.DOCKER_IMAGE_WITH_TAG }} -o docker-image.tar      # Optionally upload the .tar file as a workflow artifact      - name: Upload Image Tar as Artifact (Optional)        if: env.DOWNLOAD_IMAGE == 'true'        uses: actions/upload-artifact@v4        with:          name: docker-image          path: docker-image.tar      # Run the custom JavaScript action to gather system and Git information      - name: Run System & Git Info Action        id: docker_info_action # Unique ID        uses: ./.github/actions/javascript        with:          show_extended_info: 'true' # Show more details in this job      # Log the timestamp output from the custom info action      - name: Log Timestamp from Info Action        run: |          echo "Docker Info Action Timestamp: ${{ steps.docker_info_action.outputs.formatted_run_timestamp }}"  update-deployment:    name: 3️⃣ Update Kubernetes Deployment    runs-on: ubuntu-latest    needs: docker-build-push # This job depends on the successful completion of 'docker-build-push'    defaults:      run:        shell: bash    env:      # Get the image tag from the 'docker-build-push' job's output      IMAGE_TAG: ${{ needs.docker-build-push.outputs.image_tag }}    steps:      # Debug step to log the received IMAGE_TAG      - name: Debug Job Inputs        run: |          echo "Received IMAGE_TAG from 'docker-build-push' job: ${{ env.IMAGE_TAG }}"          if [[ -z "${{ env.IMAGE_TAG }}" ]]; then            echo "Error: IMAGE_TAG is empty. Check 'docker-build-push' job outputs."            exit 1          fi      # Checkout the repository to access the Kubernetes YAML files      - name: Checkout Repository        uses: actions/checkout@v4        with:          # Token with write permissions is needed to push changes back to the repo.          # Consider using a PAT or a GitHub App token for more fine-grained permissions.          token: ${{ secrets.PAT_FOR_REPO_WRITE || secrets.GITHUB_TOKEN }}      # Construct the full Docker image name using the received tag      - name: Set Full Docker Image Name        id: image_setter        run: |          FULL_DOCKER_IMAGE="${{ env.USER }}/${{ env.REPO_NAME }}:${{ env.IMAGE_TAG }}"          echo "FULL_DOCKER_IMAGE=${FULL_DOCKER_IMAGE}" >> $GITHUB_ENV          echo "Updating Kubernetes deployment with image: ${FULL_DOCKER_IMAGE}"      # Patch the Kubernetes Deployment.yaml file with the new image      - name: Patch Kubernetes Deployment YAML        run: |          # Note: 'sed' for YAML manipulation can be brittle.          # Consider tools like 'yq' or 'kustomize' for more complex or robust updates.          DEPLOYMENT_FILE="K8s_Yaml/App/Deployment.yaml"          if [ ! -f "$DEPLOYMENT_FILE" ]; then            echo "Error: Deployment file not found at $DEPLOYMENT_FILE"            exit 1          fi          echo "Current image line(s) in $DEPLOYMENT_FILE:"          grep 'image:' "$DEPLOYMENT_FILE" || echo "No 'image:' line found."          # Attempt to replace the image. This assumes a simple 'image: owner/repo:tag' structure.          sed -i -E "s|image:.*|image: ${{ env.FULL_DOCKER_IMAGE }}|g" "$DEPLOYMENT_FILE"          echo "Updated $DEPLOYMENT_FILE content:"          cat "$DEPLOYMENT_FILE"      # Verify that the image in the Deployment.yaml file was updated correctly      - name: Verify Deployment Image Update        run: |          DEPLOYMENT_FILE="K8s_Yaml/App/Deployment.yaml"          EXPECTED_IMAGE="${{ env.FULL_DOCKER_IMAGE }}"          # More robust check, handles potential leading/trailing spaces from sed          ACTUAL_IMAGE=$(grep 'image:' "$DEPLOYMENT_FILE" | head -1 | awk '{print $2}' | tr -d '[:space:]')          if [[ -z "$ACTUAL_IMAGE" ]]; then            echo "ERROR: Image value not found in $DEPLOYMENT_FILE after update!"            exit 1          fi          if [[ "$ACTUAL_IMAGE" != "$EXPECTED_IMAGE" ]]; then            echo "ERROR: Image value in $DEPLOYMENT_FILE did not update correctly!"            echo "Expected: $EXPECTED_IMAGE"            echo "Found   : $ACTUAL_IMAGE"            exit 1          fi          echo "Image value in $DEPLOYMENT_FILE updated successfully to: $ACTUAL_IMAGE"      # Commit and push the changes to Deployment.yaml back to the repository      - name: Commit and Push Deployment Changes        run: |          git config --global user.name "GitHub Actions Bot"          git config --global user.email "actions-bot@github.com" # Or a no-reply email          if [[ -z $(git status --porcelain K8s_Yaml/App/Deployment.yaml) ]]; then            echo "No changes to commit in K8s_Yaml/App/Deployment.yaml."          else            git add K8s_Yaml/App/Deployment.yaml            git commit -m "chore(deploy): Update Kubernetes deployment image to ${{ env.FULL_DOCKER_IMAGE }}"            # Ensure the branch name is correct, especially for PRs vs direct pushes            git push origin HEAD:${{ github.ref_name }}            echo "Committed and pushed deployment update."          fi      # Run the custom JavaScript action to gather system and Git information      - name: Run System & Git Info Action        id: deploy_info_action # Unique ID        uses: ./.github/actions/javascript        with:          show_extended_info: 'true'      # Log the timestamp output from the custom info action      - name: Log Timestamp from Info Action        run: |          echo "Deploy Info Action Timestamp: ${{ steps.deploy_info_action.outputs.formatted_run_timestamp }}"  report-failure: # Renamed for clarity    name: 📝 Report Workflow Failure    runs-on: ubuntu-latest    needs: [build-artifact, docker-build-push, update-deployment] # Depends on all primary jobs    if: failure() # Only runs if any of the needed jobs fail    steps:      # Gather information about the workflow failure and output it to the job summary      - name: Gather Failure Information        run: |          echo "## Workflow Failure Report" >> $GITHUB_STEP_SUMMARY          echo "One or more jobs failed in the 'Build and Deploy' workflow." >> $GITHUB_STEP_SUMMARY          echo "Workflow run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY          echo "Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY          echo "Triggered by: ${{ github.event_name }} by @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY          echo "" >> $GITHUB_STEP_SUMMARY          echo "### Job Statuses:" >> $GITHUB_STEP_SUMMARY          echo "* Build Artifact Job: \`${{ needs.build-artifact.result }}\`" >> $GITHUB_STEP_SUMMARY          echo "* Docker Build & Push Job: \`${{ needs.docker-build-push.result }}\`" >> $GITHUB_STEP_SUMMARY          echo "* Update Deployment Job: \`${{ needs.update-deployment.result }}\`" >> $GITHUB_STEP_SUMMARY          echo "" >> $GITHUB_STEP_SUMMARY          echo "<details><summary>Full GitHub Context (for debugging)</summary>" >> $GITHUB_STEP_SUMMARY          echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY          echo "${{ toJSON(github) }}" >> $GITHUB_STEP_SUMMARY          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY          echo "</details>" >> $GITHUB_STEP_SUMMARY          # For console log          echo "Workflow Failure Details:"          echo "  Run URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"          echo "  Commit: ${{ github.sha }}"          echo "  Build Artifact Job: ${{ needs.build-artifact.result }}"          echo "  Docker Build & Push Job: ${{ needs.docker-build-push.result }}"          echo "  Update Deployment Job: ${{ needs.update-deployment.result }}"